Я бы хотел реализовать вариант AML fraud движка, который используется у меня сейчас, но несколько его усовершенствовать в плане нефукнциональных требований, но уменьшить до минимума его функциональные возможности


На вход API Gateway прилетает POST запрос с описанием транзакции и id ruleset, через который ее надо прогнать, чтобы проверить что она не от злоумышленников.
Гейтвей его редиректит на сервис engine, который по rulesetId забирает набор правил (написанных предвариательно)
engine прогоняет все рулы, в которые входят правила валидации самой транзакции, включая внутренние правила (например внутренний black-list) и валидация у стороннего провайдера (здесь будет имитироваться значительный лаг)
Если все рулы ответили true, то транзакция хорошая, посылаем OK в notification service, если хоть один ответил false останавливаем обработку и посылаем NOK
В любом случае транзакция сохраняется в быстром хранилище для последующей возможной обработки.
Рулы описываются и хранятся в отдельном сервисе, который имеет свой жизненный цикл и может обновляться чаще и безболезненней чем сам engine. Engine должен быть супер available
Можно добавить сервис биллинг для того чтобы потренить распределенную транзакцию.
Ролевую модель можно сделать минимальной: USER, VIP_USER, ADMIN. Юзеры и вип юзеры могут только запрашивать рулы и вызывать валидацию транзакции (fraud). Админы могут менять транзакции, но не могут
запускать валидации. Випы от не випов отличаются только ценой за проверку

Запуск валидации транзакций хочу сделать через EventSourcing и CQRS (через фреймворк Axon). В качестве быстрого хранилища на чтение хочу использовать ElasticSearch
Остальной функционал через стандартный РЕСТ

Список микросервисов:
api-gateway
sso/keycloak
rule-engine
rule-manager
profile
billing (опционально)
notification
provider-mock

sso
Сервис аутентификации. Реализовать с помощью keycloak. Должен хранить userId из profile сервиса в атрибутах и засовывать его в токен


notification
Сервис уведомлений. В идеале должен уметь слать уведомления разным транспортом: email, SMS, Slack, Telagram etc. Должен уметь группировать уведомления и отсылать их не по одиночно, а в батчах.
В рамках проекта оставляем только минимальный минимум. Сервис долженг уметь:
- отсылать email уведомления. Настоящую отсылку имитируем сохранением в БД со статусом SENT
- получение сообщений нужно реализовать через синхронный АПИ (РЕСТ) и через асинхронный (Axon via RMQ)
- retryable механизм в случае неудачной отсылки
- ендпоинты для менеджмента состояния сервиса: список отосланных сообщений итд

provider-mock
Сервис, который имитирует взаимодействие с внешним провадером. В реальном проекте этот сервис может быть адаптером, который стандартизирует взаимодействие всех внутренних сервисом с АПИ провайдера, включая логику авторизации
В рамках проекта сервис должен уметь:
- получать сообщение для внешнего провайдера
- имитировать задержку ответа
- имитировать редкие сбои ответа

profile
Сервис управления профилями пользователей. Может содержать логику пермишеннов и групп пермишеннов, а также другую информацию привязанную к пользователю. Нужен для того чтобы не засовывать всю метаинформацию о пользователей
в токен, который может разрастись безразмерно. В рамках проекта сервис должен уметь:

- получать информацию о пользователе по id, включая роли
- управлять пермишенами. Ролевая модель ограничена 3 пермишенами: USER, VIP_USER, ADMIN
- создавать пользователя и синхронизировать его с SSO

api-gateway
Сервис входная точка в кластер. На этом уровне происходит роутинг во все внутренние сервисы кластера, перенаправление неаутентифицированног пользователя в ССО, а также парсинг токена и заполнение заголовков из токена и profile-service'а
Является узким местом системы, поэтому критично его написать на реактивном стеке. В рамках проетка сервис долен уметь:

- роутить на внутренние сервисы по пути запроса
- валидировать токен (с помощью ССО)
- парсить токен, забирая оттуда userId и дополнять информацию о пользователе из profile-service
- наполнять заголовки запроса из предыдущего пункта и прокидывать запрос дальше
- возможно кешировать пользователя (опционально)


rule-engine
Центральный сервис. Получает синхронный запрос (как будто от внешнего клиента). По ruleSetId находит рулсет (получает его из сервиса rule-manager) и прогоняет по всем рулам из рулсета. Здесь имитируем должгие запросы к
внешнему провайдеру, имитируем свой внтуренний black-list. Если все рулы ответили true то посылаем письмо счастья, если  хоть один рул ответил false посылаем письмо несчастья. После прогона транзакцию складируем в быстрое
хранилище (ElasticSearch). В последствии нужно уметь посмотерть транзакции (их по идее должно быть очень очень много). Все рулы нужно реализовать с помощью асинхронного взаимодействия (и возможно паралельно сделать синхронное и померить время)


rule-manager
Отдельный сервис в котором можно будет управлять рулами и рулсетами. Он нужен чтобы разделить сам енжин который должен быть супер быстрый и независимый от сервиса где будут управлятся рулы

billing(опционально) - нафиг
Сервис, который будет имитировать списание баланса у пользователей за проведенную транзакцию. Нужен чтобы потренироваться в распределенные транзакции

Мониторинг(опционально) - нафиг
Графана, для стнадартных метрик + возможно количество обработанных транзакций с какой нибудь "бизнес" группировкой

Трассировка(опционально) - нафиг
через opentracing - чисто потренироваться. Основная пробема я думаю с реактивщиной на стороне гейтвея


Пользовательские сценарии:

Happy path

When пользователь посылает запрос с валидным токеном и валидной транзакцией на fraud-валидацию на ендпонит /api/v1/fraud
Then запрос попадает в API gateway и токен валидируется на стороне SSO и парсится userId из аттрибутов и по usedId получает детали пользователя включая пермишены
And then API gateway валидирует что пользователю разрешено использовать ендпоинты
And then API gateway наполняет заголовки (userId, userName etc) и пробрасывает запрос в engine-service(маппинг path-service настроен в гейтвее)
And then engine проверяет что клиент в транзакции не в черном списке (по email из тела запроса)
And then engine по ruleSetId получает список правил и проверяет по каждому rule из ruleSet. Все рулы отвечают true
And then engine асинхронно сохраняет транзакцию в ELK
And then engine асинхронно посылает уведомление в notification service
And then notification service асинхронно имитирует отсылку happy email
And then engine возвращает ответ API gateway
And then API gateway возвращает ответ пользователю

Client is in black list

When пользователь посылает запрос с валидным токеном и валидной транзакцией на fraud-валидацию на ендпонит /api/v1/fraud
Then запрос попадает в API gateway и токен валидируется на стороне SSO и парсится userId из аттрибутов и по usedId получает детали пользователя включая пермишены
And then API gateway валидирует что пользователю разрешено использовать ендпоинты
And then API gateway наполняет заголовки (userId, userName etc) и пробрасывает запрос в engine-service(маппинг path-service настроен в гейтвее)
And then engine проверяет что клиент в транзакции в черном списке (по email из тела запроса). Процесс проверки завершается
And then engine асинхронно сохраняет транзакцию в ELK
And then engine асинхронно посылает уведомление в notification service
And then notification service асинхронно имитирует отсылку sad email
And then engine возвращает ответ API gateway
And then API gateway возвращает ответ пользователю

Transaction violates rule from ruleset

When пользователь посылает запрос с валидным токеном и валидной транзакцией на fraud-валидацию на ендпонит /api/v1/fraud
Then запрос попадает в API gateway и токен валидируется на стороне SSO и парсится userId из аттрибутов и по usedId получает детали пользователя включая пермишены
And then API gateway валидирует что пользователю разрешено использовать ендпоинты
And then API gateway наполняет заголовки (userId, userName etc) и пробрасывает запрос в engine-service(маппинг path-service настроен в гейтвее)
And then engine проверяет что клиент в транзакции не в черном списке (по email из тела запроса)
And then engine по ruleSetId получает список правил и проверяет по каждому rule из ruleSet. Второй рул из списка возвращает false.  Процесс проверки завершается
And then engine асинхронно сохраняет транзакцию в ELK
And then engine асинхронно посылает уведомление в notification service
And then notification service асинхронно имитирует отсылку sad email
And then engine возвращает ответ API gateway
And then API gateway возвращает ответ пользователю


User do not have permission to perform transaction validation

When пользователь посылает запрос с валидным токеном и валидной транзакцией на fraud-валидацию на ендпонит /api/v1/fraud
Then запрос попадает в API gateway и токен валидируется на стороне SSO и парсится userId из аттрибутов и по usedId получает детали пользователя включая пермишены
And then API gateway валидирует что пользователю НЕ разрешено использовать ендпоинт /fraud. Процесс завершается













